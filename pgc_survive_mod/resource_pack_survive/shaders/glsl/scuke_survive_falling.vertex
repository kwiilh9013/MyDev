// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.
precision highp float;

#if __VERSION__ >= 300
// version 300 code
#define texture2D texture
#else
// version 100 code
#endif

#include "vertexVersionCentroidUV.h"
#include "uniformPerFrameConstants.h"
#include "uniformWorldConstants.h"
#include "uniformEntityConstants.h"
#include "uniformShaderConstants.h"
#ifdef USE_SKINNING
#include "uniformAnimationConstants.h"
#endif

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0; // base map



attribute mediump vec4 POSITION;
attribute vec2 TEXCOORD_0;
attribute vec4 NORMAL;
#if defined(USE_SKINNING)
#ifdef MCPE_PLATFORM_NX
attribute uint BONEID_0;
#else
attribute float BONEID_0;
#endif
#endif

const float AMBIENT = 0.45;

const float XFAC = -0.1;
const float ZFAC = 0.1;

float lightIntensity(vec4 position, vec4 normal) {
#ifdef FANCY
#if defined(NETEASE_SKINNING) && defined(USE_SKINNING)
	MAT4 boneMat = GetBoneMatForNetease(int(BONEID_0));
    vec3 N = normalize( boneMat * NORMAL ).xyz;
#else//NETEASE_SKINNING
	vec3 N = normalize( WORLD * normal ).xyz;
#endif
	N.y *= TILE_LIGHT_COLOR.w; //TILE_LIGHT_COLOR.w contains the direction of the light

	//take care of double sided polygons on materials without culling
#ifdef FLIP_BACKFACES
#if defined(NETEASE_SKINNING) && defined(USE_SKINNING)
	vec3 viewDir = normalize( boneMat * POSITION ).xyz;
#else //NETEASE_SKINNING
	vec3 viewDir = normalize((WORLD * position).xyz);
#endif
	if( dot(N, viewDir) > 0.0 )
		N *= -1.0;
#endif

	float yLight = (1.0+N.y) * 0.5;
	return yLight * (1.0-AMBIENT) + N.x*N.x * XFAC + N.z*N.z * ZFAC + AMBIENT;

#else
	return 1.0;
#endif
}

const float radius = 8.0;
const float uv_step = 0.01;
const float block_size = 0.5;
const float fall_speed = 3.5;
const float fall_speed_random = 0.1;
const float height = 1.0 / uv_step * block_size;
const float y_offset = -15.0;

flat varying vec4 noiseColor;
flat varying vec4 texColor;
varying vec4 fogColor;

float calculateAngle(vec3 v1, vec3 v2)
{
    vec3 normalized_v1 = normalize(v1);
    vec3 normalized_v2 = normalize(v2);
    float dotProduct = dot(normalized_v1, normalized_v2);
    dotProduct = clamp(dotProduct, -1.0, 1.0);
    return acos(dotProduct);
}

mat3 calculateYAxisRotation(vec3 dir, vec3 normal)
{
    float theta = calculateAngle(vec3(dir.x, 0.0, dir.z), vec3(normal.x, 0.0, normal.z));
	if (normal.x < 0.0)
	{
		theta = -theta;
	}
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        c, 0.0, s,
        0.0, 1.0, 0.0,
        -s, 0.0, c
    );
}

uniform vec4 EXTRA_VECTOR1; // (密度, 速度)
uniform vec4 EXTRA_VECTOR2; // 颜色

void main()
{
	vec4 entitySpacePosition;
	vec4 entitySpaceNormal;

#ifdef USE_SKINNING
#ifdef NETEASE_SKINNING
		MAT4 boneMat = GetBoneMatForNetease(int(BONEID_0));
		entitySpacePosition = boneMat * POSITION;
		entitySpaceNormal = boneMat * NORMAL;
#else
	#if defined(LARGE_VERTEX_SHADER_UNIFORMS)
		entitySpacePosition = BONES[int(BONEID_0)] * POSITION;
		entitySpaceNormal = BONES[int(BONEID_0)] * NORMAL;
	#else
		entitySpacePosition = BONE * POSITION;
		entitySpaceNormal = BONE * NORMAL;
	#endif
#endif
#else
	entitySpacePosition = POSITION * vec4(1.0);
	entitySpaceNormal = NORMAL * vec4(1.0, 1.0, 1.0, 0.0);
#endif
	
	vec3 dc = -entitySpaceNormal.xyz;
	dc = normalize(dc);
	entitySpacePosition /= entitySpacePosition.w;
	entitySpacePosition.xyz = entitySpacePosition.xyz * 16.0;
	// 中心
	float yC = floor(TEXCOORD_0.y / uv_step);
	float xC = floor(TEXCOORD_0.x / uv_step);
	vec3 up = vec3(0.0, 1.0, 0.0);
	vec3 right = normalize(cross(up, dc));
	vec3 center = entitySpacePosition.xyz;
	vec2 uv_offset = vec2((xC+0.5)*uv_step-TEXCOORD_0.x, (yC+0.5)*uv_step-TEXCOORD_0.y);
	center += sign(uv_offset.y)*up*block_size*0.5;
	center += sign(uv_offset.x)*right*block_size*0.5;
	// 噪音偏移
	noiseColor = texture2D(TEXTURE_0, TEXCOORD_0);
    float noise = (noiseColor.r-0.13);
	float noise_x = noiseColor.g-0.5;
	float noise_z = noiseColor.b-0.5;
	float dn = noise*64.0;
	float dnn = dn*block_size/radius*2.0;
	entitySpacePosition.x += dc.x*dn-noise_x*dnn;
	entitySpacePosition.z += dc.z*dn+noise_z*dnn;
	center.x += dc.x*dn-noise_x*dnn;
	center.z += dc.z*dn+noise_z*dnn;
	// 下落偏移
	float speed = fall_speed*EXTRA_VECTOR1.y*(1.0+fall_speed_random*noise_x*noise_z);
	float y = -mod(TIME*speed, height);
	if (yC * block_size + y < 0.0) y += height;
	entitySpacePosition.y += y+y_offset;
	center.y += y+y_offset;
	// 相机
	mat4 mv = WORLDVIEW;
	mv[3].xyz = vec3(0.0);
	vec4 pos = mv * entitySpacePosition;
	// 朝向
	vec3 normal = normalize((mv * entitySpaceNormal).xyz);
	mat3 rotationMatrix = calculateYAxisRotation(pos.xyz, normal);
	vec3 offset = entitySpacePosition.xyz-center;
	entitySpacePosition.xyz = rotationMatrix * offset + center;
	
	pos = mv * entitySpacePosition;
	uv = clamp((sign(uv_offset)+vec2(1.0))/2.0, vec2(0.0), vec2(1.0));
	noiseColor.b = noiseColor.b - EXTRA_VECTOR1.x;
	texColor = EXTRA_VECTOR2;
	gl_Position = PROJ * pos;
	//fog
	fogColor.rgb = FOG_COLOR.rgb;
	fogColor.a = clamp(((length(pos.xyz) / RENDER_DISTANCE)) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.3, 0.6);
}
